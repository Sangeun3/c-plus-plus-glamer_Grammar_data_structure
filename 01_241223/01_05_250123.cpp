#include <iostream>

using namespace std;

int main() {
	// 상수 : 변하지 않는 수. 값을 한 번 지정해놓으면 바꿀 수 없다.
	// 상수는 선언과 동시에 값을 지정해두어야 한다.
	const int iAttack = 0x00000001; // 2진수로 '1'
	const int iArmor  = 0x00000002; // '10'
	const int iHP	  = 0x00000004; // '100'
	const int iMP     = 0x00000008; //'1000'
	const int iCritical = 0x00000010; // '10000' (1,2,3,4,~9,A~F)

		// int는 4바이트 (32비트)
		// 16진수 한 자리에 16가지 기호 중 하나를 사용할 수 있다.
		// 16진수 한 자리 -> 2진수 4자리와 대응 0000~1111 로 표현 가능
		// 16진수 8자리 -> 2의 2*8승 -> 32비트
/*
	16진수	십진수	2진수(4비트)
		0	0	0000
		1	1	0001
		2	2	0010
		3	3	0011
		4	4	0100
		5	5	0101
		6	6	0110
		7	7	0111
		8	8	1000
		9	9	1001
		A	10	1010
		B	11	1011
		C	12	1100
		D	13	1101
		E	14	1110
		F	15	1111
*/
    // 001 | 100 = 101 -> 00101 | 10000 = 10101 
	int iBuf = iAttack | iHP | iCritical;

	cout << "Attack : " << (iBuf & iAttack) << endl; // 10101 & 00001 = 1
	cout << "Armor : " << (iBuf & iArmor) << endl; // 10101 & 00010 = 0
	cout << "HP : " << (iBuf & iHP) << endl; // 10101 & 00100 = 100
	cout << "MP : " << (iBuf & iMP) << endl; // 10101 & 01000 = 0
	cout << "Critical : " << (iBuf & iCritical) << endl;// 10101 & 10000 = 10000

	// 왜 배열로 안 쓸까? 컴퓨터는 이진수를 좋아해서 속도가 빠르다
	// 그래서 안 쓰는 거예요
	

	// 연산자 축약형 : 연산자를 줄여서 사용할 수 있다.
	// 아래를 풀어서 쓰면 iBuf = iBuf ^ iHP;
	// 10101 ^ 00100 = 10001
	iBuf ^= iHP;

	// 10001 ^ 00100 = 10101
	iBuf ^= iHP;
	// iHP를 없앴다, 생기게 했다 껐다킬 수 있다.
 }